'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _reactAddons = require('react/addons');

var _reactAddons2 = _interopRequireDefault(_reactAddons);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _pureRenderDecorator = require('pure-render-decorator');

var _pureRenderDecorator2 = _interopRequireDefault(_pureRenderDecorator);

var _utils = require('utils');

var ReactTransitionGroup = _reactAddons2['default'].addons.TransitionGroup;
var BEMSeparator = '--';

/**
 * A MutableListView represents a single, vertical list from which items
 * can be added, deleted, and rearranged. Each item can contain any
 * combination of DOM elements or React components desired by the user.
 * e.g.
 *
 *  <List>
 *    <ListItem>Hello</ListItem>
 *    <ListItem><b>World!</b></ListItem>
 *  </List>
 *
 * MutableList automatically applies BEM-style class names to allow the
 * user to easily style the list in its various states. The first
 * className passed into a List or ListItem is used as a base class. All
 * modifier classes are named like `{baseClass}--{modifier}`. If no
 * classes are given to the list components, default base classes of
 * 'ReactList' and 'ReactList-item' are used.
 *
 * When a user is dragging an item, the dragged item and the list will
 * get a modifier of 'dragging'.
 */

var MutableListView = (function (_React$Component) {
  _inherits(MutableListView, _React$Component);

  function MutableListView(props) {
    _classCallCheck(this, _MutableListView);

    _get(Object.getPrototypeOf(_MutableListView.prototype), 'constructor', this).call(this, props);

    this.state = {
      dragItem: null,
      dragIndex: 0,
      dragTransform: [0, 0],
      deletedIndex: -1,
      deletedHeight: 0,
      deletedCallback: null
    };
  }

  _createDecoratedClass(MutableListView, [{
    key: '_onItemDelete',
    decorators: [_autobindDecorator2['default']],
    value: function _onItemDelete(index, height, cb) {
      if (index === _reactAddons2['default'].Children.count(this.props.children)) {
        cb();
        return;
      }

      this.setState(function (state) {
        // If another item has not finished its delete transition, delete
        // this one immediately.
        if (state.deletedCallback != null) {
          cb();
          return;
        }

        return {
          deletedIndex: index,
          deletedHeight: height,
          deletedCallback: cb
        };
      });
    }
  }, {
    key: '_onItemDeleted',
    value: function _onItemDeleted() {
      this.state.deletedCallback();
      this.setState({
        deletedIndex: -1,
        deletedHeight: 0,
        deletedCallback: null
      });
    }
  }, {
    key: '_onItemTransitionEnd',
    decorators: [_autobindDecorator2['default']],
    value: function _onItemTransitionEnd(_index, e) {
      if (this.state.deletedCallback == null || e.propertyName !== 'transform') {
        return;
      }

      this._onItemDeleted();
    }
  }, {
    key: '_onDragStart',
    decorators: [_autobindDecorator2['default']],
    value: function _onDragStart(item, _e) {
      this.setState({
        dragItem: item,
        dragIndex: this._getNewIndex(item),
        dragTransform: [0, 0]
      });
    }
  }, {
    key: '_onDrag',
    decorators: [_autobindDecorator2['default']],
    value: function _onDrag(item, e) {
      var _this = this;

      var offset = item.dragOffset;
      var delta = (0, _utils.pointerOffset)(e, item.getBoundingClientRect());

      this.setState(function (state) {
        return {
          dragIndex: _this._getNewIndex(item),
          dragTransform: [state.dragTransform[0] + delta[0] - offset[0], state.dragTransform[1] + delta[1] - offset[1]]
        };
      });
    }
  }, {
    key: '_onDragEnd',
    decorators: [_autobindDecorator2['default']],
    value: function _onDragEnd(item, _e) {
      var oldIndex = item.props.index;
      var newIndex = this._getNewIndex(item);

      if (oldIndex !== newIndex) {
        this.props.onReorder(oldIndex, newIndex);
      }

      this.setState({
        dragItem: null
      });
    }
  }, {
    key: '_getNewIndex',
    value: function _getNewIndex(item) {
      var rect = item.getBoundingClientRect();
      var midpoint = rect.top + rect.height / 2;

      // Find the top of the list in terms of the client viewport,
      var list = _reactAddons2['default'].findDOMNode(this);

      // Search through every list item and find the appropriate index
      var stop = list.getBoundingClientRect().top;
      var newIndex = 0;
      for (var i = 0, len = list.children.length; i < len; i++) {
        var el = list.children[i];
        stop += (0, _utils.outerHeight)(el);
        if (stop > midpoint) {
          break;
        } else {
          ++newIndex;
        }
      }

      return newIndex;
    }
  }, {
    key: 'render',
    value: function render() {
      var _classSet,
          _this2 = this;

      var newIndex = this.state.dragIndex;
      var oldIndex = this.state.dragItem != null ? this.state.dragItem.props.index : -1;
      var maxIndex = Math.max(newIndex, oldIndex);
      var minIndex = Math.min(newIndex, oldIndex);

      var transform = this.state.dragTransform;
      var itemHeight = this.state.dragItem != null ? this.state.dragItem.getOuterHeight() : this.state.deletedHeight;

      var upTransformString = 'translateY(-' + itemHeight + 'px)';
      var dragTransformString = newIndex < oldIndex ? 'translateY(' + itemHeight + 'px)' : upTransformString;

      var items = _reactAddons2['default'].Children.map(this.props.children, function (child, i) {
        var style = child.props.style || {};
        var enableTransformTransitions = false;

        if (_this2.state.deletedIndex !== -1 && i >= _this2.state.deletedIndex) {
          enableTransformTransitions = true;
          style.transform = upTransformString;
        }

        if (_this2.state.dragItem != null) {
          if (i === _this2.state.dragItem.props.index) {
            // Translate the dragged element to the cursor
            style.transform = 'translate(' + transform[0] + 'px, ' + transform[1] + 'px)';
          } else {
            enableTransformTransitions = true;
            if (i >= minIndex && i <= maxIndex) {
              style.transform = dragTransformString;
            }
          }
        }

        return _reactAddons2['default'].cloneElement(child, {
          style: style,
          index: i,
          enableTransformTransitions: enableTransformTransitions,
          transitionDuration: child.props.transitionDuration || _this2.props.transitionDuration,
          onDragStart: _this2._onDragStart,
          onDrag: _this2._onDrag,
          onDragEnd: _this2._onDragEnd,
          onDelete: _this2._onItemDelete,
          onTransitionEnd: _this2._onItemTransitionEnd
        });
      });

      var baseClass = 'ReactList';
      if (this.props.className) {
        baseClass = this.props.className.split(' ')[0];
      }

      var className = (0, _classnames2['default'])(this.props.className, (_classSet = {}, _defineProperty(_classSet, '' + baseClass + BEMSeparator + 'dragging', this.state.dragItem != null), _defineProperty(_classSet, '' + baseClass + BEMSeparator + 'deleting', this.state.deletedIndex !== -1), _classSet));

      if (this.props.enableDeleteTransitions) {
        return _reactAddons2['default'].createElement(
          ReactTransitionGroup,
          {
            component: 'ul',
            className: className
          },
          items
        );
      }

      return _reactAddons2['default'].createElement(
        'ul',
        { className: className },
        items
      );
    }
  }]);

  var _MutableListView = MutableListView;
  MutableListView = (0, _pureRenderDecorator2['default'])(MutableListView) || MutableListView;
  return MutableListView;
})(_reactAddons2['default'].Component);

MutableListView.defaultProps = {
  enableDeleteTransitions: false,
  onReorder: function onReorder() {},
  transitionDuration: 300
};

MutableListView.propTypes = {
  /**
   * When a list item is deleted and `enableDeleteTransitions` is true,
   * elements below the deleted one will be transitioned into their new
   * place in the list.
   */
  enableDeleteTransitions: _reactAddons2['default'].PropTypes.bool,
  /**
   * Function called whenever list items are dragged into a new
   * position, with a signature of (oldIndex, newIndex).
   */
  onReorder: _reactAddons2['default'].PropTypes.func,
  /**
   * Duration of the transform transition for each of the list's
   * children. Can be overridden item by item by setting it directly on
   * the list items.
   */
  transitionDuration: _reactAddons2['default'].PropTypes.number
};

exports['default'] = MutableListView;
module.exports = exports['default'];